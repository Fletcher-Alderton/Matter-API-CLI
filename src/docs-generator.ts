#!/usr/bin/env bun

import * as fs from 'fs/promises';
import * as path from 'path';


const RESULTS_FILE = 'src/json/api-results.json';
const SUCCESSFUL_ENDPOINTS_FILE = 'src/json/successful-endpoints.json';
const DOCS_DIR = 'src/docs';
const MARKDOWN_DOCS_FILE = path.join(DOCS_DIR, 'matter-api-docs.md');

// Create the docs directory if it doesn't exist
(async function ensureDocsDir() {
  try {
    await fs.mkdir(DOCS_DIR, { recursive: true });
  } catch (error) {
    console.error('Error creating docs directory:', error);
  }
})();

/**
 * Generates markdown documentation from API exploration results
 */
async function generateDocs() {
  try {
    // Check if results exist
    const resultsExist = await fileExists(RESULTS_FILE);
    const summaryExists = await fileExists(SUCCESSFUL_ENDPOINTS_FILE);
    
    if (!resultsExist || !summaryExists) {
      console.error('API exploration results not found. Please run the API explorer first.');
      process.exit(1);
    }
    
    // Load the results
    const resultsData = await fs.readFile(RESULTS_FILE, 'utf8');
    const results = JSON.parse(resultsData);
    
    const summaryData = await fs.readFile(SUCCESSFUL_ENDPOINTS_FILE, 'utf8');
    const successfulEndpoints = JSON.parse(summaryData);
    
    // Generate the markdown
    let markdown = '# Matter API Documentation\n\n';
    markdown += 'This documentation was automatically generated by exploring the Matter API endpoints.\n\n';
    markdown += 'Last updated: ' + new Date().toISOString() + '\n\n';
    
    markdown += '## API Base URL\n\n';
    markdown += '```\nhttps://api.getmatter.app/api/v11/\n```\n\n';
    
    markdown += '## Available Endpoints\n\n';
    
    // Group endpoints by category
    const categories = groupEndpointsByCategory(successfulEndpoints);
    
    // Add table of contents
    markdown += '### Table of Contents\n\n';
    for (const category of Object.keys(categories).sort()) {
      markdown += `- [${formatCategoryName(category)}](#${category.toLowerCase()})\n`;
    }
    markdown += '\n';
    
    // Add endpoint details by category
    for (const [category, endpoints] of Object.entries(categories).sort()) {
      markdown += `### ${formatCategoryName(category)}\n\n`;
      
      for (const endpoint of endpoints) {
        const endpointPath = endpoint.endpoint;
        const resultData = results[endpointPath];
        
        markdown += `#### \`${endpointPath}\`\n\n`;
        
        // Supported methods
        markdown += 'Supported Methods: ';
        markdown += endpoint.methods.map((m: string) => `\`${m}\``).join(', ');
        markdown += '\n\n';
        
        // Parameters (if any)
        if (endpoint.params && endpoint.params.length > 0) {
          markdown += 'Supported Parameters:\n';
          for (const param of endpoint.params) {
            markdown += `- \`${param}\`\n`;
          }
          markdown += '\n';
        }
        
        // Response schema
        for (const method of endpoint.methods) {
          if (resultData[method] && resultData[method].success) {
            markdown += `##### ${method} Response Schema\n\n`;
            markdown += '```json\n';
            markdown += JSON.stringify(resultData[method].dataSchema, null, 2);
            markdown += '\n```\n\n';
            
            // Example response preview
            markdown += `##### ${method} Response Example\n\n`;
            markdown += '```json\n';
            markdown += JSON.stringify(resultData[method].dataPreview, null, 2);
            markdown += '\n```\n\n';
          }
        }
        
        // Add parameter examples if available
        if (resultData.withParams) {
          markdown += '##### Example with Parameters\n\n';
          
          for (const [param, paramResult] of Object.entries(resultData.withParams)) {
            if ((paramResult as any).success) {
              markdown += `###### With \`${param}\`\n\n`;
              markdown += '```json\n';
              markdown += JSON.stringify((paramResult as any).dataPreview, null, 2);
              markdown += '\n```\n\n';
            }
          }
        }
        
        markdown += '---\n\n';
      }
    }
    
    // Write the markdown file
    await fs.writeFile(MARKDOWN_DOCS_FILE, markdown);
    console.log(`API documentation generated at ${MARKDOWN_DOCS_FILE}`);
    
  } catch (error) {
    console.error('Error generating API docs:', error);
  }
}

/**
 * Groups endpoints by their category based on path structure
 */
function groupEndpointsByCategory(endpoints: any[]): Record<string, any[]> {
  const categories: Record<string, any[]> = {};
  
  for (const endpoint of endpoints) {
    const path = endpoint.endpoint;
    const category = path.split('/')[0];
    
    if (!categories[category]) {
      categories[category] = [];
    }
    
    categories[category].push(endpoint);
  }
  
  return categories;
}

/**
 * Formats a category name for display
 */
function formatCategoryName(category: string): string {
  return category
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Checks if a file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

// Run the doc generator if this script is executed directly
if (require.main === module) {
  generateDocs();
}

export { generateDocs }; 